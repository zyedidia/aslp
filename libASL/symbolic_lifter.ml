open Asl_ast
open Asl_utils
open Asl_visitor
open Visitor

(* TODO:
  dis:
  - Improve simplifications based on branching conditions
  - For loop support
  - BitTuple support
  - Investigate CSE performance issues

  symbolic_lifter:
  - Remove unsupported_set with overrides.asl instead
  - Remove unsupported globals, including partial record removal

  ocaml_backend:
  - Break output into many files, better comp + debugging
  - Identities on gen_ prims rather immediately building expressions
  - Cleaner tuple unpacking

  offline:
  - Reduce the number of runtime temporaries generated by offline_transform
*)

(* Set of functions we do not want to analyse / inline due to their complexity *)
let unsupported_set = IdentSet.of_list [
  FIdent ("AArch64.TranslateAddress", 0);
  FIdent ("AArch64.Abort", 0);
  FIdent ("Unreachable", 0);
  FIdent ("AArch64.ExclusiveMonitorsPass", 0);
  FIdent ("AArch64.SetExclusiveMonitors", 0);
]

(* Problematic instruction encoding names, due to various disassembly issues *)
let problematic_enc = [
  (* >10k lines due to unrolling/splitting *)
  "aarch64_memory_vector_multiple_no_wb";
  "aarch64_memory_vector_multiple_post_inc";

  (* Need to extend RemoveUnsupported to remove all undesirable global variables & fields *)
  "aarch64_system_register_system";
  "aarch64_system_register_cpsr";
]

(* Model doesn't need these globals *)
(* Need to model these for coverage, but really should be excluded
let dead_globals =  IdentSet.of_list [
  Ident "BTypeCompatible";
  Ident "__BranchTaken";
  Ident "BTypeNext";
  Ident "__ExclusiveLocal";
] *)
let dead_globals = IdentSet.empty

(** Trivial walk to replace unsupported calls with a corresponding throw *)
module RemoveUnsupported = struct
  let assert_false loc = Stmt_Throw(Ident ("UNSUPPORTED"), loc)

  class expr_visitor unsupported env = object
    inherit Asl_visitor.nopAslVisitor
    val mutable seen = false
    method! vexpr e =
      (match e with
      | Expr_TApply (f, _, _) ->
          if unsupported f then (seen <- true; SkipChildren)
          else DoChildren
      | Expr_ImpDef(t, Some(s)) ->
          (try
            let _ = Eval.Env.getImpdef Unknown env s in
            DoChildren
          with _ ->
            match t with
            | Type_Constructor(Ident "boolean") -> ChangeTo (Symbolic.expr_false)
            | _ -> (seen <- true; DoChildren))
      | Expr_ImpDef _ -> (seen <- true; DoChildren)
      | _ -> DoChildren)
    method has_unsupported = seen
  end

  let contains_unsupported e unsupported env =
    let v = new expr_visitor unsupported env in
    let _ = visit_expr v e in
    v#has_unsupported

  class call_visitor unsupported env = object
    inherit Asl_visitor.nopAslVisitor

    method! vstmt e =
      (match e with
      | Stmt_Assert(e, loc) ->
          if contains_unsupported e unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_VarDeclsNoInit _
      | Stmt_ProcReturn _ -> DoChildren

      | Stmt_FunReturn (e, loc) ->
          if contains_unsupported e unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_VarDecl(ty, v, e, loc) ->
          if contains_unsupported e unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_ConstDecl(ty, v, e, loc) ->
          if contains_unsupported e unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_Assign(v, e, loc) ->
          if contains_unsupported e unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_TCall (f, tes, es, loc) ->
          if unsupported f then ChangeTo (assert_false loc)
          else if List.exists (fun e -> contains_unsupported e unsupported env) (tes @ es) then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_If (c, t, alts, f, loc) ->
          if contains_unsupported c unsupported env then ChangeTo (assert_false loc)
          else if List.exists (fun (S_Elsif_Cond(c,_)) -> contains_unsupported c unsupported env) alts then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_Case (e, alts, odefault, loc) ->
          if contains_unsupported e unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_While (c, b, loc) ->
          if contains_unsupported c unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_For(var, start, dir, stop, body, loc) ->
          if contains_unsupported start unsupported env then ChangeTo (assert_false loc)
          else if contains_unsupported stop unsupported env then ChangeTo (assert_false loc)
          else DoChildren

      | Stmt_Dep_Undefined loc
      | Stmt_Undefined loc
      | Stmt_Unpred loc
      | Stmt_ConstrainedUnpred loc
      | Stmt_ImpDef (_, loc)
      | Stmt_ExceptionTaken loc
      | Stmt_Dep_Unpred loc
      | Stmt_Dep_ImpDef (_, loc)
      | Stmt_See (_, loc)
      | Stmt_Throw (_, loc)
      | Stmt_DecodeExecute (_, _, loc) -> ChangeTo (assert_false loc)

      | _ -> failwith @@ "Unknown stmt: " ^ (pp_stmt e))
  end

  let run unsupported env body =
    let v = new expr_visitor unsupported env in
    let body = visit_stmts v body in
    let v = new call_visitor unsupported env in
    visit_stmts v body

end

let unsupported f = IdentSet.mem f unsupported_set

let get_inlining_frontier =
  (* Collect all functions dis will not inline *)
  let l1 = IdentSet.of_list (List.map (fun (f,i) -> FIdent (f,i)) Dis.no_inline) in
  let l2 = IdentSet.of_list (List.map (fun (f,i) -> FIdent (f,i)) Dis.no_inline_pure) in
  (* Collect all prims *)
  let l3 = IdentSet.of_list (List.map (fun f -> FIdent (f,0)) Value.prims_pure) in
  let l4 = IdentSet.of_list (List.map (fun f -> FIdent (f,0)) Value.prims_impure) in
  (* Union with the unsupported function set *)
  IdentSet.union l1 (IdentSet.union l2 (IdentSet.union l3 (IdentSet.union l4 unsupported_set)))

(* Count individual stmts present after disassembly *)
let rec stmt_count s =
  match s with
  | Stmt_If (_,t,[],f,_) ->
      1 + stmts_count t + stmts_count f
  | _ -> 1
and stmts_count s =
  List.fold_right (fun s acc -> stmt_count s + acc) s 0

module Cleanup = struct

  let rec is_throw_unsupported s =
    match s with
    | (Stmt_Throw (Ident "UNSUPPORTED", loc))::xs -> true
    | x::xs -> is_throw_unsupported xs
    | _ -> false

  (* Remove unsupported instr bodies *)
  class call_visitor = object
    inherit nopAslVisitor
    method! vstmt e =
      let reduce e = (match e with
      | Stmt_Throw(_,loc)
      | Stmt_Unpred(loc)
      | Stmt_ConstrainedUnpred(loc)
      | Stmt_ImpDef(_, loc)
      | Stmt_Undefined(loc)
      | Stmt_ExceptionTaken(loc)
      | Stmt_Dep_Unpred(loc)
      | Stmt_Dep_ImpDef(_, loc)
      | Stmt_Dep_Undefined(loc)
      | Stmt_See(_, loc)
      | Stmt_Assert(Expr_Var (Ident "FALSE"), loc) ->
          (RemoveUnsupported.assert_false loc)

      | Stmt_If(c, t, els, f, loc) ->
          if is_throw_unsupported t &&
              List.for_all (fun (S_Elsif_Cond(_,b)) -> is_throw_unsupported b) els &&
                is_throw_unsupported f then
            (RemoveUnsupported.assert_false loc)
          else e
      | _ -> e) in
      ChangeDoChildrenPost(e, reduce)
  end

  let rec trim_post_term stmts =
    List.fold_right (fun stmt acc ->
      match stmt with
      | Stmt_Throw _ -> [stmt]
      | Stmt_If (c, t, [], f, loc) ->
          let t = trim_post_term t in
          let f = trim_post_term f in
          (match t, f with
          | [Stmt_Throw _], [Stmt_Throw _] -> t
          | _ -> Stmt_If (c, t, [], f, loc)::acc)
      | _ -> stmt::acc) stmts []

  let run verb stmts =
    let v = new call_visitor in
    let stmts = (visit_stmts v) stmts in
    trim_post_term stmts

end

module DecoderCleanup = struct

  (* Remove unsupported decode tests *)
  class expr_visitor unsupported = object
    inherit nopAslVisitor
    method! vexpr e =
      (match e with
      | Expr_TApply (f, _, _) ->
          let suffix = "_decode_test" in
          if String.ends_with ~suffix (name_of_FIdent f) && unsupported f then ChangeTo (Symbolic.expr_true)
          else DoChildren
      | _ -> DoChildren)
  end

  let rec is_throw_unsupported s =
    match s with
    | (Stmt_Throw (Ident "UNSUPPORTED", loc))::xs -> true
    | x::xs -> is_throw_unsupported xs
    | _ -> false

  (* Remove unsupported instr bodies *)
  class call_visitor unsupported  = object
    inherit nopAslVisitor
    method! vstmt e =
      let reduce e = (match e with
      | Stmt_TCall (f, _, _, loc) ->
          if unsupported f then (RemoveUnsupported.assert_false loc)
          else e
      | Stmt_Throw(_, loc)
      | Stmt_Unpred(loc)
      | Stmt_ConstrainedUnpred(loc)
      | Stmt_ImpDef(_, loc)
      | Stmt_Undefined(loc)
      | Stmt_ExceptionTaken(loc)
      | Stmt_Dep_Unpred(loc)
      | Stmt_Dep_ImpDef(_, loc)
      | Stmt_Dep_Undefined(loc)
      | Stmt_See(_, loc)
      | Stmt_Assert(Expr_Var (Ident "FALSE"), loc) ->
          (RemoveUnsupported.assert_false loc)

      | Stmt_If(c, t, els, f, loc) ->
          if is_throw_unsupported t &&
              List.for_all (fun (S_Elsif_Cond(_,b)) -> is_throw_unsupported b) els &&
                is_throw_unsupported f then
            (RemoveUnsupported.assert_false loc)
          else e
      | _ -> e) in
      ChangeDoChildrenPost(e, reduce)
  end

  let run unsupported dsig =
    let v = new expr_visitor unsupported in
    let dsig = (visit_stmts v) dsig in
    let v = new call_visitor unsupported in
    let dsig = (visit_stmts v) dsig in
    dsig
end

let unsupported_inst tests instrs f =
  not (Bindings.mem f tests || Bindings.mem f instrs)

let dis_wrapper fn fnsig env =
  let (lenv,globals) = Dis.build_env env in
  try
    let body = fnsig_get_body fnsig in
    let sym = Symbolic.Exp (Expr_Var (Decoder_program.enc)) in
    let (_,lenv,_) = (Dis.declare_assign_var Unknown (Type_Bits (Expr_LitInt "32")) (Ident "enc") sym) env lenv in
    let ((),lenv',stmts) = (Dis.dis_stmts body) env lenv in
    let globals = IdentSet.diff globals dead_globals in
    let stmts = Dis.flatten stmts [] in
    let stmts' = Transforms.RemoveUnused.remove_unused globals @@ stmts in
    let stmts' = Transforms.RedundantSlice.do_transform Bindings.empty stmts' in
    let stmts' = Transforms.StatefulIntToBits.run (Dis.enum_types env) stmts' in
    let stmts' = Transforms.IntToBits.ints_to_bits stmts' in
    (*let stmts' = Transforms.CommonSubExprElim.do_transform stmts' in*)
    let stmts' = Transforms.CopyProp.copyProp stmts' in
    let stmts' = Transforms.RemoveUnused.remove_unused globals @@ stmts' in
    let stmts' = Transforms.RemoveRegisters.run stmts' in
    let stmts' = Cleanup.run false stmts' in
    let stmts' = Transforms.RemoveUnused.remove_unused globals @@ stmts' in
    Some stmts'
  with
  | e ->
      let m = Printexc.to_string e in
      let m = if String.length m > 100 then String.sub m 0 100 ^ "..." else m in
      Printf.printf "Error: %s %s\n" (name_of_FIdent fn) m;
      None

(* Produce a lifter for the desired parts of the instruction set *)
let run iset pat env =
  Printf.printf "Stage 1: Mock decoder & instruction encoding definitions\n";
  let ((did,dsig),tests,instrs) = Decoder_program.run iset pat env problematic_enc in
  Printf.printf "  Collected %d instructions\n\n" (Bindings.cardinal instrs);

  Printf.printf "Stage 2: Call graph construction\n";
  let frontier = get_inlining_frontier in
  let (callers, reachable) = Call_graph.run (bindings_domain instrs) frontier env in
  let fns = IdentSet.fold (fun id acc -> Bindings.add id (Eval.Env.getFun Unknown env id) acc) reachable Bindings.empty in
  Printf.printf "  Collected %d functions\n\n" (Bindings.cardinal fns);

  Printf.printf "Stage 3: Simplification\n";
  (* Remove temporary dynamic bitvectors where possible *)
  let fns = Bindings.map (fnsig_upd_body (Transforms.RemoveTempBVs.do_transform false)) fns in
  (* Remove calls to problematic functions & impdefs *)
  let fns = Bindings.map (fnsig_upd_body (RemoveUnsupported.run unsupported env)) fns in
  Printf.printf "\n";

  Printf.printf "Stage 4: Specialisation\n";
  (* Run requirement collection over the full set *)
  let fns = Req_analysis.run fns callers in
  Printf.printf "\n";

  Printf.printf "Stage 5: Disassembly\n";
  (* Build an environment with these new function definitions *)
  let env' = Eval.Env.copy env in
  Bindings.iter (fun  fn fnsig  -> Eval.Env.addFun Unknown env' fn fnsig) fns;
  (* Run dis over the entry set identifiers with this new environment *)
  let fns = Bindings.filter_map (fun fn fnsig ->
    if not (Bindings.mem fn instrs) then None
    else Option.map (fnsig_set_body fnsig) (dis_wrapper fn fnsig env')) fns in
  Printf.printf "  Succeeded for %d instructions\n\n" (Bindings.cardinal fns);

  Printf.printf "Stmt Counts\n";
  let l = Bindings.fold (fun fn fnsig acc -> (fn, stmts_count (fnsig_get_body fnsig))::acc) fns [] in
  let l = List.sort (fun (_,i) (_,j) -> compare i j) l in
  List.iter (fun (fn,c) -> Printf.printf "  %d\t:\t%s\n" c (name_of_FIdent fn)) l;
  Printf.printf "\n";

  Printf.printf "Stage 6: Cleanup\n";
  (* TODO: Defer *)
  let tests = Bindings.map (fun s -> fnsig_upd_body (Transforms.RemoveUnused.remove_unused IdentSet.empty) s) tests in
  Printf.printf "\n";

  (* Perform offline PE *)
  Printf.printf "Stages 7-8: Offline Transform\n";
  let offline_fns = Offline_transform.run fns env in
  let dsig = fnsig_upd_body (DecoderCleanup.run (unsupported_inst tests offline_fns)) dsig in
  let dsig = fnsig_upd_body (Transforms.RemoveUnused.remove_unused IdentSet.empty) dsig in
  Printf.printf "\n";

  (did,dsig,tests,offline_fns)
